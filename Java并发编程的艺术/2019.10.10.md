##volatile关键字和锁

由于volatile仅保证对单个volatile变量的读、写具有原子性,而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上,锁比volatile更强大;在可伸缩性和执行性能上, volatile更有优势。

## 锁的释放和获取的内存语义

当线程释放锁时, JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。
当线程获取锁时, JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。

## CAS同时具有volatile读和volatile写的内存语义

intel的手册对lock前缀的说明如下。
1)确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中,带有1ock前缀的指令在执行期间会创住总线,使得其他处理器暂时无法通过总线访问内存。很显然,这会带来昂贵的开销。从Pentium 4, Intel Xeon及P6处理器开始, Intel使用缓存锁定(Cache Locking)来保证指令执行的原子性。缓存锁定将大大降低lock前缀指令的执行开销。
2)禁止该指令,与之前和之后的读和写指令重排序。
3)把写缓冲区中的所有数据刷新到内存中。
上面的第2点和第3点所具有的内存屏障效果,足以同时实现volatile读和volatile写的内存语义。

## 公平锁和非公平锁的内存语义总结

公平锁和非公平锁释放时,最后都要写一个volatile变量state
公平锁获取时,首先会去读volatile变量
非公平锁获取时,首先会用CAS更新volatile变量,这个操作同时具有volatile读和volatile写的内存语义。

从本文对ReentrantLock的分析可以看出,锁释放-获取的内存语义的实现至少有下面两种方式。
1)利用volatile变量的写-读所具有的内存语义。
2)利用CAS所附带的volatile读和volatile写的内存语义。

## JUC包实现的基石

Java的CAS会使用现代处理器上提供的高效机器级别的原子指令,这些原子指令以原子方式对内存执行读-改-写操作,这是在多处理器中实现同步的关键(从本质上来说,能够支持原子性读改-写指令的计算机,是顺序计算图灵机的异步等价机器,因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令) 。同时, volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起,就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现,会发现一个通用化的实现模式：
首先,声明共享变量为volatile
然后,使用CAS的原子条件更新来实现线程之间的同步
同时,配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。

## JUC实现

![concurrent包实现示意图](C:\Users\Administrator.MACHENI-KA32LTP\Desktop\Essence\ReadNotes\Java并发编程的艺术\concurrent包实现.JPG)

