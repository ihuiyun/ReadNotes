# JMM

## 基础问题

### 线程间如何通信

1.共享内存     隐式通信，显式同步
2.消息传递     显式通信，隐式同步

### 线程间如何同步

共享内存模型中，需要我们控制方法或代码之间互斥进行。而消息传递的模型中，消息的发送必须是在接收之前

## JMM的抽象

Java线程之间的通信由Java内存模型(本文简称为JMM)控制, JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看, JMM定义了线程和主内存之间的抽象关系:线程之间的共享变量存储在主内存(Main . Memory)中,每个线程都有一个私有的本地内存(Local Memory) ,本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念,并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化

一个线程A要和线程B通信的话，必须经历以下两个步骤
1.线程A把本地内存A中更新过的共享变量刷新到主内存中
2.线程B从主内存中重新读取共享变量到本地内存

## 指令重排

1.编译器优化重排序
2.指令级别并行重排序（CPU）
3.内存系统重排序（CPU）

对于编译器，JMM的编译器会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令来禁止CPU特定类型指令重排

