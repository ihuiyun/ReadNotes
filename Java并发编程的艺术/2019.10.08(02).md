# JMM

## 基础问题

### 线程间如何通信

1.共享内存     隐式通信，显式同步
2.消息传递     显式通信，隐式同步

### 线程间如何同步

共享内存模型中，需要我们控制方法或代码之间互斥进行。而消息传递的模型中，消息的发送必须是在接收之前

## JMM的抽象

Java线程之间的通信由Java内存模型(本文简称为JMM)控制, JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看, JMM定义了线程和主内存之间的抽象关系:线程之间的共享变量存储在主内存(Main . Memory)中,每个线程都有一个私有的本地内存(Local Memory) ,本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念,并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化

一个线程A要和线程B通信的话，必须经历以下两个步骤
1.线程A把本地内存A中更新过的共享变量刷新到主内存中
2.线程B从主内存中重新读取共享变量到本地内存

## 指令重排

1.编译器优化重排序
2.指令级别并行重排序（CPU）
3.内存系统重排序（CPU）

对于编译器，JMM的编译器会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令来禁止CPU特定类型指令重排

## happened-before

两个操作之间具有happens-before关系,并不意味着前一个操作必须要在后一个操作之前执行! happens before仅仅要求前一个操作(执行的结果)对后一个操作可见,且前一个操作按顺序排在第二个操作之前(the first is visible to and ordered before the second) , happens-before的定义很微妙,后文会具体说明happens-before为什么要这么定义。

## volatile关键字

锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性,这意味着对一个volatile变量的读,总是能看到(任意线程)对这个volatile变量最后的写入。锁的语义决定了临界区代码的执行具有原子性。这意味着,即使是64位的long型和double型变量,只要它是volatile变量,对该变量的读/写就具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作,这些操作整体上不具有原子性。
        简而言之, volatile变量自身具有下列特性。
·可见性。对一个volatile变量的读,总是能看到(任意线程)对这个volatile变量最后的写入。
·原子性:对任意单个volatile变量的读/写具有原子性,但类似于volatile++这种复合操作不具有原子性。